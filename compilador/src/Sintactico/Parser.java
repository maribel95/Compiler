
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

package Sintactico;

import Codigo3Direcciones.GeneradorCodigo3D;
import Codigo3Direcciones.Operador;
import Ensamblador.GeneradorCodigoEnsamblador;
import Enumerados.CategoriaOperador;
import Enumerados.Operacion3Direcciones;
import java_cup.runtime.*;
import Simbolos.*;
import Lexico.AnalizadorLexico;
import Enumerados.DescripcionValor;
import EstructurasDatos.TablaSimbolos;
import Enumerados.TipoSubjacenteBasico;
import Ficheros.GestorFicheros;
import EstructurasDatos.DescripcionTipo;
import EstructurasDatos.NodoTabla;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.logging.Level;
import java.util.logging.Logger;
import java_cup.runtime.XMLElement;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class Parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return ParserSym.class;
}

  /** Default constructor. */
  @Deprecated
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\103\000\002\002\004\000\002\024\004\000\002\002" +
    "\004\000\002\002\003\000\002\003\003\000\002\003\003" +
    "\000\002\003\003\000\002\003\003\000\002\003\003\000" +
    "\002\003\003\000\002\003\003\000\002\020\007\000\002" +
    "\013\006\000\002\010\010\000\002\005\014\000\002\006" +
    "\015\000\002\006\003\000\002\007\012\000\002\007\003" +
    "\000\002\015\013\000\002\046\005\000\002\043\004\000" +
    "\002\043\004\000\002\014\007\000\002\031\005\000\002" +
    "\030\005\000\002\030\005\000\002\032\005\000\002\032" +
    "\003\000\002\032\004\000\002\026\003\000\002\026\002" +
    "\000\002\025\003\000\002\025\002\000\002\033\005\000" +
    "\002\036\005\000\002\036\003\000\002\034\005\000\002" +
    "\034\003\000\002\034\003\000\002\034\003\000\002\035" +
    "\005\000\002\004\003\000\002\037\003\000\002\017\013" +
    "\000\002\017\003\000\002\045\007\000\002\041\003\000" +
    "\002\041\002\000\002\042\006\000\002\042\004\000\002" +
    "\044\005\000\002\044\002\000\002\040\003\000\002\011" +
    "\002\000\002\012\002\000\002\021\002\000\002\022\002" +
    "\000\002\023\002\000\002\027\003\000\002\027\003\000" +
    "\002\027\003\000\002\027\004\000\002\027\003\000\002" +
    "\027\003\000\002\027\003\000\002\016\002" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\224\000\006\002\uffc9\012\uffc9\001\002\000\004\002" +
    "\226\001\002\000\006\002\uffbf\012\uffbf\001\002\000\006" +
    "\002\uffd4\012\uffd4\001\002\000\006\002\000\012\010\001" +
    "\002\000\004\024\214\001\002\000\004\017\012\001\002" +
    "\000\004\020\013\001\002\000\016\006\uffcb\011\uffcb\012" +
    "\uffcb\014\uffcb\015\uffcb\024\uffcb\001\002\000\016\006\021" +
    "\011\022\012\016\014\015\015\020\024\031\001\002\000" +
    "\004\016\210\001\002\000\004\024\203\001\002\000\022" +
    "\006\ufffc\011\ufffc\012\ufffc\013\ufffc\014\ufffc\015\ufffc\021" +
    "\ufffc\024\ufffc\001\002\000\004\016\177\001\002\000\004" +
    "\016\133\001\002\000\004\016\uffbf\001\002\000\022\006" +
    "\ufffe\011\ufffe\012\ufffe\013\ufffe\014\ufffe\015\ufffe\021\ufffe" +
    "\024\ufffe\001\002\000\022\006\ufffd\011\ufffd\012\ufffd\013" +
    "\ufffd\014\ufffd\015\ufffd\021\ufffd\024\ufffd\001\002\000\022" +
    "\006\021\011\022\012\016\013\121\014\015\015\020\021" +
    "\uffcd\024\031\001\002\000\022\006\ufff8\011\ufff8\012\ufff8" +
    "\013\ufff8\014\ufff8\015\ufff8\021\ufff8\024\ufff8\001\002\000" +
    "\022\006\ufffa\011\ufffa\012\ufffa\013\ufffa\014\ufffa\015\ufffa" +
    "\021\ufffa\024\ufffa\001\002\000\022\006\ufff9\011\ufff9\012" +
    "\ufff9\013\ufff9\014\ufff9\015\ufff9\021\ufff9\024\ufff9\001\002" +
    "\000\010\004\035\005\036\024\uffe0\001\002\000\022\006" +
    "\ufffb\011\ufffb\012\ufffb\013\ufffb\014\ufffb\015\ufffb\021\ufffb" +
    "\024\ufffb\001\002\000\022\006\ufff7\011\ufff7\012\ufff7\013" +
    "\ufff7\014\ufff7\015\ufff7\021\ufff7\024\ufff7\001\002\000\004" +
    "\024\114\001\002\000\004\024\uffe1\001\002\000\020\012" +
    "\016\016\043\024\050\025\047\026\uffe2\027\040\030\041" +
    "\001\002\000\030\012\uffc6\016\uffc6\017\uffc6\022\uffc6\024" +
    "\uffc6\025\uffc6\026\uffc6\027\uffc6\030\uffc6\031\uffc6\032\uffc6" +
    "\001\002\000\030\012\uffc2\016\uffc2\017\uffc2\022\uffc2\024" +
    "\uffc2\025\uffc2\026\uffc2\027\uffc2\030\uffc2\031\uffc2\032\uffc2" +
    "\001\002\000\004\026\uffe3\001\002\000\004\022\113\001" +
    "\002\000\020\012\016\016\056\024\063\025\061\026\uffe2" +
    "\027\040\030\041\001\002\000\004\026\051\001\002\000" +
    "\030\012\uffc1\016\uffc1\017\uffc1\022\uffc1\024\uffc1\025\uffc1" +
    "\026\uffc1\027\uffc1\030\uffc1\031\uffc1\032\uffc1\001\002\000" +
    "\030\012\uffc4\016\uffc4\017\uffc4\022\uffc4\024\uffc4\025\uffc4" +
    "\026\uffc4\027\uffc4\030\uffc4\031\uffc4\032\uffc4\001\002\000" +
    "\026\012\uffc5\016\uffc5\017\uffc5\022\uffc5\024\uffc5\025\uffc5" +
    "\026\uffc5\027\uffc5\030\uffc5\032\uffc5\001\002\000\026\012" +
    "\uffc0\016\uffc0\017\uffc0\022\uffc0\024\uffc0\025\uffc0\026\uffc0" +
    "\027\uffc0\030\uffc0\032\uffc0\001\002\000\030\012\uffc3\016" +
    "\uffc3\017\uffc3\022\uffc3\024\uffc3\025\uffc3\026\uffc3\027\uffc3" +
    "\030\uffc3\031\uffc3\032\uffc3\001\002\000\006\017\uffdd\032" +
    "\uffdd\001\002\000\006\017\112\032\101\001\002\000\004" +
    "\030\110\001\002\000\004\031\106\001\002\000\020\012" +
    "\016\016\056\024\063\025\061\026\uffe2\027\040\030\041" +
    "\001\002\000\004\026\075\001\002\000\006\017\uffda\032" +
    "\uffda\001\002\000\010\017\uffdb\031\uffc5\032\uffdb\001\002" +
    "\000\006\017\064\030\065\001\002\000\012\017\uffd9\030" +
    "\uffe5\031\uffc0\032\uffd9\001\002\000\030\012\uffe9\016\uffe9" +
    "\017\uffe9\022\uffe9\024\uffe9\025\uffe9\026\uffe9\027\uffe9\030" +
    "\uffe9\031\uffe9\032\uffe9\001\002\000\012\016\071\024\066" +
    "\026\uffe2\030\041\001\002\000\006\017\uffe5\030\uffe5\001" +
    "\002\000\004\026\074\001\002\000\006\017\uffe8\030\uffe8" +
    "\001\002\000\012\016\071\024\066\026\uffe2\030\041\001" +
    "\002\000\006\017\073\030\065\001\002\000\006\017\uffe6" +
    "\030\uffe6\001\002\000\006\017\uffe4\030\uffe4\001\002\000" +
    "\006\030\uffe4\031\uffc3\001\002\000\006\017\102\032\101" +
    "\001\002\000\006\017\100\030\065\001\002\000\006\030" +
    "\uffe6\031\uffe9\001\002\000\020\012\016\016\104\024\105" +
    "\025\061\026\uffe2\027\040\030\041\001\002\000\010\017" +
    "\uffdc\031\uffdf\032\uffdc\001\002\000\006\017\uffde\032\uffde" +
    "\001\002\000\020\012\016\016\056\024\063\025\061\026" +
    "\uffe2\027\040\030\041\001\002\000\010\017\uffd9\031\uffc0" +
    "\032\uffd9\001\002\000\020\012\016\016\043\024\050\025" +
    "\047\026\uffe2\027\040\030\041\001\002\000\006\017\uffd8" +
    "\032\uffd8\001\002\000\012\016\071\024\066\026\uffe2\030" +
    "\041\001\002\000\006\017\uffe7\030\uffe7\001\002\000\030" +
    "\012\uffdf\016\uffdf\017\uffdf\020\uffdf\022\uffdf\024\uffdf\025" +
    "\uffdf\026\uffdf\027\uffdf\030\uffdf\032\uffdf\001\002\000\022" +
    "\006\ufff5\011\ufff5\012\ufff5\013\ufff5\014\ufff5\015\ufff5\021" +
    "\ufff5\024\ufff5\001\002\000\004\005\115\001\002\000\020" +
    "\012\016\016\043\024\050\025\047\026\uffe2\027\040\030" +
    "\041\001\002\000\004\022\117\001\002\000\022\006\ufff4" +
    "\011\ufff4\012\ufff4\013\ufff4\014\ufff4\015\ufff4\021\ufff4\024" +
    "\ufff4\001\002\000\022\006\uffff\011\uffff\012\uffff\013\uffff" +
    "\014\uffff\015\uffff\021\uffff\024\uffff\001\002\000\020\012" +
    "\016\016\043\024\050\025\047\026\uffe2\027\040\030\041" +
    "\001\002\000\004\021\uffca\001\002\000\004\021\124\001" +
    "\002\000\006\002\uffd5\012\uffd5\001\002\000\004\022\126" +
    "\001\002\000\004\021\uffce\001\002\000\004\016\uffcc\001" +
    "\002\000\004\016\133\001\002\000\004\020\134\001\002" +
    "\000\004\020\uffd7\001\002\000\020\012\016\016\104\024" +
    "\105\025\061\026\uffe2\027\040\030\041\001\002\000\016" +
    "\006\uffcb\011\uffcb\012\uffcb\014\uffcb\015\uffcb\024\uffcb\001" +
    "\002\000\016\006\uffc8\011\uffc8\012\uffc8\014\uffc8\015\uffc8" +
    "\024\uffc8\001\002\000\016\006\021\011\022\012\016\014" +
    "\015\015\020\024\031\001\002\000\020\006\021\011\022" +
    "\012\016\014\015\015\020\021\uffca\024\031\001\002\000" +
    "\004\021\141\001\002\000\022\006\uffee\011\uffee\012\uffee" +
    "\013\uffee\014\uffee\015\uffee\021\uffee\024\uffee\001\002\000" +
    "\004\020\143\001\002\000\016\006\uffcb\011\uffcb\012\uffcb" +
    "\014\uffcb\015\uffcb\024\uffcb\001\002\000\016\006\uffc8\011" +
    "\uffc8\012\uffc8\014\uffc8\015\uffc8\024\uffc8\001\002\000\016" +
    "\006\021\011\022\012\016\014\015\015\020\024\031\001" +
    "\002\000\020\006\021\011\022\012\016\014\015\015\020" +
    "\021\uffca\024\031\001\002\000\004\021\150\001\002\000" +
    "\026\006\uffbf\007\uffbf\010\uffbf\011\uffbf\012\uffbf\013\uffbf" +
    "\014\uffbf\015\uffbf\021\uffbf\024\uffbf\001\002\000\026\006" +
    "\uffc7\007\uffbf\010\uffbf\011\uffc7\012\uffc7\013\uffc7\014\uffc7" +
    "\015\uffc7\021\uffc7\024\uffc7\001\002\000\026\006\ufff1\007" +
    "\ufff1\010\ufff1\011\ufff1\012\ufff1\013\ufff1\014\ufff1\015\ufff1" +
    "\021\ufff1\024\ufff1\001\002\000\006\007\uffd6\010\uffd6\001" +
    "\002\000\022\006\uffef\011\uffef\012\uffef\013\uffef\014\uffef" +
    "\015\uffef\021\uffef\024\uffef\001\002\000\006\007\160\010" +
    "\157\001\002\000\022\006\ufff3\011\ufff3\012\ufff3\013\ufff3" +
    "\014\ufff3\015\ufff3\021\ufff3\024\ufff3\001\002\000\004\020" +
    "\171\001\002\000\004\016\uffc7\001\002\000\004\016\133" +
    "\001\002\000\004\020\163\001\002\000\016\006\uffcb\011" +
    "\uffcb\012\uffcb\014\uffcb\015\uffcb\024\uffcb\001\002\000\016" +
    "\006\uffc8\011\uffc8\012\uffc8\014\uffc8\015\uffc8\024\uffc8\001" +
    "\002\000\016\006\021\011\022\012\016\014\015\015\020" +
    "\024\031\001\002\000\020\006\021\011\022\012\016\014" +
    "\015\015\020\021\uffca\024\031\001\002\000\004\021\170" +
    "\001\002\000\026\006\ufff2\007\ufff2\010\ufff2\011\ufff2\012" +
    "\ufff2\013\ufff2\014\ufff2\015\ufff2\021\ufff2\024\ufff2\001\002" +
    "\000\016\006\uffcb\011\uffcb\012\uffcb\014\uffcb\015\uffcb\024" +
    "\uffcb\001\002\000\016\006\uffc7\011\uffc7\012\uffc7\014\uffc7" +
    "\015\uffc7\024\uffc7\001\002\000\016\006\021\011\022\012" +
    "\016\014\015\015\020\024\031\001\002\000\020\006\021" +
    "\011\022\012\016\014\015\015\020\021\uffca\024\031\001" +
    "\002\000\004\021\176\001\002\000\022\006\ufff0\011\ufff0" +
    "\012\ufff0\013\ufff0\014\ufff0\015\ufff0\021\ufff0\024\ufff0\001" +
    "\002\000\020\012\016\016\043\024\050\025\047\026\uffe2" +
    "\027\040\030\041\001\002\000\004\017\201\001\002\000" +
    "\004\022\202\001\002\000\022\006\uffea\011\uffea\012\uffea" +
    "\013\uffea\014\uffea\015\uffea\021\uffea\024\uffea\001\002\000" +
    "\004\016\207\001\002\000\022\012\016\016\043\017\206" +
    "\024\050\025\047\026\uffe2\027\040\030\041\001\002\000" +
    "\022\012\uffec\016\uffec\017\uffec\024\uffec\025\uffec\026\uffec" +
    "\027\uffec\030\uffec\001\002\000\044\006\uffed\011\uffed\012" +
    "\uffed\013\uffed\014\uffed\015\uffed\016\uffed\017\uffed\021\uffed" +
    "\022\uffed\024\uffed\025\uffed\026\uffed\027\uffed\030\uffed\031" +
    "\uffed\032\uffed\001\002\000\022\012\uffeb\016\uffeb\017\uffeb" +
    "\024\uffeb\025\uffeb\026\uffeb\027\uffeb\030\uffeb\001\002\000" +
    "\004\024\211\001\002\000\004\017\212\001\002\000\004" +
    "\022\213\001\002\000\022\006\ufff6\011\ufff6\012\ufff6\013" +
    "\ufff6\014\ufff6\015\ufff6\021\ufff6\024\ufff6\001\002\000\004" +
    "\024\215\001\002\000\004\016\216\001\002\000\006\017" +
    "\uffd1\024\220\001\002\000\004\017\uffd3\001\002\000\004" +
    "\024\225\001\002\000\006\017\uffd2\023\222\001\002\000" +
    "\004\024\223\001\002\000\004\024\224\001\002\000\006" +
    "\017\uffd0\023\uffd0\001\002\000\006\017\uffcf\023\uffcf\001" +
    "\002\000\004\002\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\224\000\006\021\004\024\003\001\001\000\002\001" +
    "\001\000\006\016\005\017\006\001\001\000\002\001\001" +
    "\000\004\045\010\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\011\013\001\001\000\024" +
    "\002\024\003\022\005\031\010\016\013\023\014\025\015" +
    "\026\020\032\046\027\001\001\000\002\001\001\000\004" +
    "\043\203\001\001\000\002\001\001\000\002\001\001\000" +
    "\006\004\141\033\131\001\001\000\006\016\126\040\127" +
    "\001\001\000\002\001\001\000\002\001\001\000\024\003" +
    "\117\005\031\010\016\013\023\014\025\015\026\020\032" +
    "\044\121\046\027\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\025\033\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\014\026\043\027\041\031\036\033\045\046\044" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\026\026\056\027\054\030\061" +
    "\031\036\032\053\033\045\034\051\035\057\036\052\046" +
    "\044\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\026\026\056\027\054\030\076\031" +
    "\036\032\053\033\045\034\051\035\057\036\075\046\044" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\006\026\066\032\067\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\010\026\066\030\071" +
    "\032\053\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\020\026\043\027\054\031" +
    "\036\033\045\034\102\035\057\046\044\001\001\000\002" +
    "\001\001\000\002\001\001\000\026\026\056\027\054\030" +
    "\061\031\036\032\053\033\045\034\051\035\057\036\075" +
    "\046\044\001\001\000\002\001\001\000\014\026\043\027" +
    "\106\031\036\033\045\046\044\001\001\000\002\001\001" +
    "\000\006\026\066\032\110\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\014" +
    "\026\043\027\115\031\036\033\045\046\044\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\014" +
    "\026\043\027\124\031\036\033\045\046\044\001\001\000" +
    "\004\012\122\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\006\004\130\033\131\001\001\000\002\001\001\000\002" +
    "\001\001\000\022\026\043\027\054\031\036\033\045\034" +
    "\051\035\057\036\052\046\044\001\001\000\004\011\134" +
    "\001\001\000\004\022\135\001\001\000\024\002\136\003" +
    "\022\005\031\010\016\013\023\014\025\015\026\020\032" +
    "\046\027\001\001\000\024\003\117\005\031\010\016\012" +
    "\137\013\023\014\025\015\026\020\032\046\027\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\011\143\001\001\000\004\022\144\001\001\000\024" +
    "\002\145\003\022\005\031\010\016\013\023\014\025\015" +
    "\026\020\032\046\027\001\001\000\024\003\117\005\031" +
    "\010\016\012\146\013\023\014\025\015\026\020\032\046" +
    "\027\001\001\000\002\001\001\000\006\006\150\016\151" +
    "\001\001\000\012\007\155\016\152\023\153\037\154\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\023\160\001\001\000\006\004\161\033\131\001\001" +
    "\000\002\001\001\000\004\011\163\001\001\000\004\022" +
    "\164\001\001\000\024\002\165\003\022\005\031\010\016" +
    "\013\023\014\025\015\026\020\032\046\027\001\001\000" +
    "\024\003\117\005\031\010\016\012\166\013\023\014\025" +
    "\015\026\020\032\046\027\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\011\171\001\001\000\004\023\172" +
    "\001\001\000\024\002\173\003\022\005\031\010\016\013" +
    "\023\014\025\015\026\020\032\046\027\001\001\000\024" +
    "\003\117\005\031\010\016\012\174\013\023\014\025\015" +
    "\026\020\032\046\027\001\001\000\002\001\001\000\002" +
    "\001\001\000\014\026\043\027\177\031\036\033\045\046" +
    "\044\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\014\026\043\027\204\031" +
    "\036\033\045\046\044\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\041\216\042\220\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



    private TablaSimbolos tablaSimbolos;
    private GeneradorCodigo3D generadorCodigo3D;
    private AnalizadorLexico escaner;
    private GestorFicheros gf;
    private GeneradorCodigoEnsamblador generadorEnsamblador;
    public Parser(AnalizadorLexico escaner, SymbolFactory sf) {
        super(escaner);
        this.gf = new GestorFicheros();
        this.tablaSimbolos = new TablaSimbolos();
        generadorCodigo3D = new GeneradorCodigo3D();
        this.escaner = escaner;
    }

    // Comprobamos si un valor corresponde a una variable, parámetro de subprograma o a un subprograma como tal
    private boolean esId(SimboloValores sv) {
        return sv.getDescripcionValor() == DescripcionValor.dvVariable || sv.getDescripcionValor() == DescripcionValor.dvArgumento || sv.getDescripcionValor() == DescripcionValor.dvSubprograma;
    }
    // Comprobamos si no es ni variable, parámetro y constante
    private boolean esTipoDescripcion(DescripcionTipo td){
        return DescripcionValor.dvVariable != td.getDescripcionValor() && DescripcionValor.dvArgumento != td.getDescripcionValor() && DescripcionValor.dvConstante != td.getDescripcionValor();
    }
    // Comprobamos si es un parámetro, variable, constante, subprograma o si es nulo
    private boolean esTipoSubjacenteBasico(SimboloValores sv){
        return (DescripcionValor.dvArgumento == sv.getDescripcionValor()) || (DescripcionValor.dvVariable == sv.getDescripcionValor())|| (DescripcionValor.dvConstante == sv.getDescripcionValor())|| (DescripcionValor.dvNull == sv.getDescripcionValor())|| (DescripcionValor.dvSubprograma == sv.getDescripcionValor());
    }
    // Comprobamos si es de algún tipo subjacente básico de los definidos
    private boolean esTipoCorrecto(DescripcionTipo td) {
        return (td.getTipoSubjacenteBasico() == TipoSubjacenteBasico.tsVoid || td.getTipoSubjacenteBasico() == TipoSubjacenteBasico.tsBooleano || td.getTipoSubjacenteBasico() == TipoSubjacenteBasico.tsString || td.getTipoSubjacenteBasico() == TipoSubjacenteBasico.tsEntero);
    }
    // Comprobamos si es de alguno de los tipos entero, booleano o cadena
    private boolean esTipoValor(TipoSubjacenteBasico valor){
        return  valor == TipoSubjacenteBasico.tsBooleano || valor == TipoSubjacenteBasico.tsEntero || valor == TipoSubjacenteBasico.tsString;
    }

    // Sirve para identificar el código de 3 direcciones que se hará según el operador
    private Operacion3Direcciones indicarOperador(String operador) {
        Operacion3Direcciones codigo = null;
        switch (operador) {
            case "+":codigo = Operacion3Direcciones.suma;break;
            case "-":codigo = Operacion3Direcciones.resta; break;
            case "/":codigo = Operacion3Direcciones.division;break;
            case "*": codigo = Operacion3Direcciones.producto;
        }
        return codigo;
    }
 
    // Realizamos la operación aritmética entre dos valores según el valor
    private int realizarOperacion(String operador, int v1, int v2) throws Exception{
        int nuevo = 0;
        switch (operador) {
            case "+":nuevo = v1 + v2;break;
            case "-":nuevo = v1 - v2;break;
            case "*":nuevo = v1 * v2;break;
            case "/":
                if (v2 == 0){
                   String mensajeError = "Excepción en la sintaxis del programa, error al realizar una división: no se puede dividir entre 0. ";
                    gf.escribirError("src/Salidas/Errores/ErroresSintacticos.txt", mensajeError);
                    throw new Exception(mensajeError);
                }
                nuevo = v1 / v2;
        }
        return nuevo;
    }
    // Comprobamos error relacionado con el tipo subyacente básico
    private void comprobarErrorTipoSubjacenteBasico(String simbolo) throws Exception{
        
        if (!esTipoCorrecto(tablaSimbolos.consultar(simbolo))) {
            String mensajeError = "Excepción en la semántica del lenguaje. No es del tipo subjacente básico correcto.";
            gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
            throw new Exception(mensajeError);             
        }   
    }

    // Comprobamos los diferentes errores relacionados con el tipo subyacente básico del valor, el tipo del valor
    // o la descripción del valor
    private TipoSubjacenteBasico comprobarValores (SimboloValores valor) throws Exception{
        TipoSubjacenteBasico valor1 = TipoSubjacenteBasico.tsVoid;
        if (DescripcionValor.dvNull == valor.getDescripcionValor()) {
            valor1 = valor.getTipoSubjacenteBasico();

        } else if (esTipoSubjacenteBasico(valor)) {                                                
            if (TipoSubjacenteBasico.tsVoid == tablaSimbolos.consultar(valor.getNombreTipo()).getTipoSubjacenteBasico()) {
                String mensajeError = "Excepción en la semántica del lenguaje. El tipo subjacente básico no puede ser void.";
                gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                throw new Exception(mensajeError);
            }else{
                valor1 = tablaSimbolos.consultar(valor.getNombreTipo()).getTipoSubjacenteBasico();
            }
        } else {
            String mensajeError = "Excepción en la semántica del lenguaje. El valor tiene una descripción valor erronea: " + valor.getDescripcionValor() + ".";
            gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
            throw new Exception(mensajeError);
        }
        // COMPROBAMOS EL TIPO SUBJACENTE BÁSICO DE LOS VALORES
        if (!esTipoValor(valor1)) {
            String mensajeError = "Excepción en la semántica del lenguaje. Tipo subjacente básico incorrecto: " + valor1 + ".";
            gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
            throw new Exception(mensajeError);
        }
        return valor1;
    }

    // Generamos la categoria de la operacion de 3 direcciones según el operador lógico
    private Operacion3Direcciones comprobarOperadorRelacional(String operador){
        Operacion3Direcciones codigo = null;
        switch (operador) {
            case ">":
                codigo = Operacion3Direcciones.mayor;
                break;
            case ">=":
                codigo = Operacion3Direcciones.mayorIgual;
                break;
            case "<":
                codigo = Operacion3Direcciones.menor;
                break;
            case "<=":
                codigo = Operacion3Direcciones.menorIgual;
                break;
            case "==":
                codigo = Operacion3Direcciones.igual;
                break;
            case "!=":
                codigo = Operacion3Direcciones.diferente;
        }
        return codigo;
    }

    // Para obtener el parámetro del subprograma
    public DescripcionTipo tipoParametro(String idVariable, int indice, Hashtable<String, NodoTabla> tablaDescripcion, LinkedList<NodoTabla> tablaExpansion) {
        try {
            if (tablaDescripcion.get(idVariable).getTipoDescripcion().getDescripcionValor() != DescripcionValor.dvSubprograma) {
                String mensajeError = "Excepción tabla símbolos: la variable escogida no es un subprograma";
                gf.escribirError("src/Salidas/Errores/ErroresTablaSimbolos.txt", mensajeError);
                throw new Exception(mensajeError);
            }else{
                int idxe;
                for(idxe  = tablaDescripcion.get(idVariable).getFirst(); indice > 0 && idxe != -1; indice--){
                    idxe = tablaExpansion.get(idxe).getFollow();
                }
                if (idxe == -1){
                    String mensajeError = "Excepción tabla símbolos: El siguiente índice no existe::" + indice;
                    gf.escribirError("src/Salidas/Errores/ErroresTablaSimbolos.txt", mensajeError);
                    throw new Exception(mensajeError);              
                }           
                return tablaExpansion.get(idxe).getTipoDescripcion();
            }          
        } catch (Exception ex) {
            Logger.getLogger(Parser.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }
    // Para obtener el número de parámetros de un subprograma
    public int numeroParametrosSubprograma(String idVariable, Hashtable<String, NodoTabla> tablaDescripcion, LinkedList<NodoTabla> tablaExpansion) throws Exception {
        if (tablaDescripcion.get(idVariable).getTipoDescripcion().getDescripcionValor() != DescripcionValor.dvSubprograma){
            String mensajeError = "Excepción en la tabla de símbolos de tipo incorrecto en el método \"NUMERO PARAMETROS SUBPROGRAMA\": la variable no es un subprograma.";
            gf.escribirError("src/Salidas/Errores/ErroresTablaSimbolos.txt", mensajeError);
            throw new Exception(mensajeError);   
        }else{
            int idxe;
            int i;
            for(i=0, idxe = tablaDescripcion.get(idVariable).getFirst(); idxe != -1; i++){
                idxe = tablaExpansion.get(idxe).getFollow();
            }
            return i;
        }
    }

    // Gestión de los ficheros, para generar las listas del código de 3 dimensiones y los ficheros de ensamblador
    public void gestionFicherosFinal() throws Exception{
        tablaSimbolos.cerrarFichero();
        generadorCodigo3D.actualizarDesplazamientos();
        gf.archivoRegistroCodigo3D("Codigo3Direcciones/ListaC3DSinOptimizar.txt", generadorCodigo3D.getListaCodigo3D());
        generadorCodigo3D.archivoRegistroTablas();
        generadorEnsamblador = new GeneradorCodigoEnsamblador(generadorCodigo3D.getListaCodigo3D(), generadorCodigo3D.getTV(), generadorCodigo3D.getTP(), generadorCodigo3D.getTablaEtiquetas());                
        generadorEnsamblador.crearCodigoEnsambladorSinOptimizar();
        generadorEnsamblador.crearCodigoEnsambladorOptimizado();
        gf.archivoRegistroCodigo3D("Codigo3Direcciones/ListaC3DOptimizada.txt", generadorCodigo3D.getListaCodigo3D());
    }


/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$Parser$actions {
  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action_part00000000(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= PRINCIPIO EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Boolean start_val = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = start_val;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // PRINCIPIO ::= M0 CREAR_FUNCION 
            {
              Boolean RESULT =null;
		 
                    gestionFicherosFinal();
                    RESULT = true;
             
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PRINCIPIO",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // INSTRUCCIONES ::= INSTRUCCIONES SENTENCIA 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTRUCCIONES",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // INSTRUCCIONES ::= SENTENCIA 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTRUCCIONES",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // SENTENCIA ::= ASIGNACION 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENTENCIA",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // SENTENCIA ::= DECLARACION 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENTENCIA",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // SENTENCIA ::= CONDICIONAL_IF 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENTENCIA",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // SENTENCIA ::= BUCLE_WHILE 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENTENCIA",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // SENTENCIA ::= LLAMAR_FUNCION 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENTENCIA",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // SENTENCIA ::= SALIDA_DATOS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENTENCIA",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // SENTENCIA ::= ENTRADA_DATOS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENTENCIA",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // ENTRADA_DATOS ::= i_stdin parentesis_izq identificador parentesis_der fin_instruccion 
            {
              Object RESULT =null;
		int simboloIdVariableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int simboloIdVariableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String simboloIdVariable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
                // CÓDIGO INTERMEDIO INSTRUCCION ENTRADA DATOS Y VARIABLE TEMPORAL
                generadorCodigo3D.getTV().nuevaVariable("Variable temporal", generadorCodigo3D.getTP().subprogramaActual(), tablaSimbolos.consultar("int").getOcupacion(), 0, tablaSimbolos.consultar("int").getTipoSubjacenteBasico());
                SimboloValores valor = new SimboloValores(tablaSimbolos.consultar("int").getTipoSubjacenteBasico());
                valor.setIdVariable(String.valueOf(generadorCodigo3D.getTV().getNv()));
                Operacion3Direcciones opEntrada = Operacion3Direcciones.entradaDatos;
                Operador opVarTemp = new Operador(String.valueOf(generadorCodigo3D.getTV().getNv()), CategoriaOperador.variable);
                generadorCodigo3D.generarCodigo3Direcciones(opEntrada, null, null, opVarTemp);

                // COMPROBAR ERROR DE ASIGNACIÓN A UNA CONSTANTE
                if (DescripcionValor.dvConstante == tablaSimbolos.consultar(simboloIdVariable).getDescripcionValor()) {
                    String mensajeError = "Excepción en la semántica del lenguaje. No se puede cambiar el valor de una constante";
                    gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                    throw new Exception(mensajeError);                    
                }
                // COMPROBAR DESCRIPCIÓN VALOR
                switch(valor.getDescripcionValor()){
                    case dvNull:
                       // MIRAMOS SI COINCIDE EL TIPO SUBJAENTE BÁSICO DE LA VARIABLE Y EL VALOR
                        if (tablaSimbolos.consultar(tablaSimbolos.consultar(simboloIdVariable).getNombreId()).getTipoSubjacenteBasico() != valor.getTipoSubjacenteBasico()) {
                            String mensajeError = "Excepción en la semántica del lenguaje. No coincide el tipo subjacente básico de la variable y del valor." + "Tipo subjacente básico variable: "+ tablaSimbolos.consultar(tablaSimbolos.consultar(simboloIdVariable).getNombreId()).getTipoSubjacenteBasico() + ". " + "Tipo subjacente básico valor: " +valor.getTipoSubjacenteBasico() + ".";
                            gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                            throw new Exception(mensajeError);                
                        }
                        break;
                    case dvVariable: case dvSubprograma: case dvArgumento:
                        // COMPROBAMOS SI COINCIDE EL TIPO DE LA VARIBALE CON EL DEL VALOR
                        if(!tablaSimbolos.consultar(simboloIdVariable).getNombreId().equals(valor.getNombreTipo())){
                            String mensajeError = "Excepción en la semántica del lenguaje. No coincide el tipo de la variable con el del valor."+ "Tipo variable: " + tablaSimbolos.consultar(simboloIdVariable).getNombreId() + ". " + "Tipo valor: " + valor.getNombreTipo() + ".";
                            gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                            throw new Exception(mensajeError);  
                        }
                        break;
                    // TIPO INCORRECTO, YA QUE NO ENTRA EN LA CATEGORIA DE LOS ANTERIORES
                    default:
                        String mensajeError = "Excepción en la semántica del lenguaje. Tipo incorrecto valor: " + valor.getDescripcionValor() + ".";
                        gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                        throw new Exception(mensajeError);                    
                        
                }
                
                // CÓDIGO INTERMEDIO--> INSTRUCCION DE COPIA SIN OPERANDO 2
                Operacion3Direcciones opCopia = Operacion3Direcciones.copia;
                Operador asignacion = new Operador(valor.getIdVariable(), CategoriaOperador.variable);
                Operador destino = new Operador(String.valueOf(tablaSimbolos.consultar(simboloIdVariable).getIdCodigoIntermedio()), CategoriaOperador.variable);
                generadorCodigo3D.generarCodigo3Direcciones(opCopia, asignacion, null, destino);
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ENTRADA_DATOS",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // ASIGNACION ::= identificador asignacion VALORES fin_instruccion 
            {
              Object RESULT =null;
		int simboloIdVariableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int simboloIdVariableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String simboloIdVariable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int simbolo_valorleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int simbolo_valorright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimboloValores simbolo_valor = (SimboloValores)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		

                // COMRPOBAR ERROR DE ASIGNACIÓN A UNA CONSTANTE
                if (DescripcionValor.dvConstante == tablaSimbolos.consultar(simboloIdVariable).getDescripcionValor()) {
                    String mensajeError = "Excepción en la semántica del lenguaje. No se puede cambiar el valor de una constante";
                    gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                    throw new Exception(mensajeError);                    
                }
                // COMPROBAR DESCRIPCIÓN VALOR
                switch(simbolo_valor.getDescripcionValor()){
                    case dvNull:
                       // MIRAMOS SI COINCIDE EL TIPO SUBJAENTE BÁSICO DE LA VARIABLE Y EL VALOR
                        if (tablaSimbolos.consultar(tablaSimbolos.consultar(simboloIdVariable).getNombreId()).getTipoSubjacenteBasico() != simbolo_valor.getTipoSubjacenteBasico()) {
                            String mensajeError = "Excepción en la semántica del lenguaje. No coincide el tipo subjacente básico de la variable y del valor." + "Tipo subjacente básico variable: "+ tablaSimbolos.consultar(tablaSimbolos.consultar(simboloIdVariable).getNombreId()).getTipoSubjacenteBasico() + ". " + "Tipo subjacente básico valor: " +simbolo_valor.getTipoSubjacenteBasico() + ".";
                            gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                            throw new Exception(mensajeError);                
                        }
                        break;
                    case dvVariable: case dvSubprograma: case dvArgumento:
                        // COMPROBAMOS SI COINCIDE EL TIPOD E LA VARIBALE CON EL DEL VALOR
                        if(!tablaSimbolos.consultar(simboloIdVariable).getNombreId().equals(simbolo_valor.getNombreTipo())){
                            String mensajeError = "Excepción en la semántica del lenguaje. No coincide el tipo de la variable con el del valor."+ "Tipo variable: " + tablaSimbolos.consultar(simboloIdVariable).getNombreId() + ". " + "Tipo valor: " + simbolo_valor.getNombreTipo() + ".";
                            gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                            throw new Exception(mensajeError);  
                        }
                        break;
                    // TIPO INCORRECTO, YA QUE NO ENTRA EN LA CATEGORIA DE LOS ANTERIORES
                    default:
                        String mensajeError = "Excepción en la semántica del lenguaje. Tipo incorrecto valor: " + simbolo_valor.getDescripcionValor() + ".";
                        gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                        throw new Exception(mensajeError);                    
                        
                }
                
                // CÓDIGO INTERMEDIO--> INSTRUCCION DE COPIA SIN OPERANDO 2
                Operacion3Direcciones opCopia = Operacion3Direcciones.copia;
                Operador asignacion = new Operador(simbolo_valor.getIdVariable(), CategoriaOperador.variable);
                Operador destino = new Operador(String.valueOf(tablaSimbolos.consultar(simboloIdVariable).getIdCodigoIntermedio()), CategoriaOperador.variable);
                generadorCodigo3D.generarCodigo3Direcciones(opCopia, asignacion, null, destino);
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ASIGNACION",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // DECLARACION ::= identificador CONSTANTE identificador asignacion VALORES fin_instruccion 
            {
              Object RESULT =null;
		int simboloTipoVariableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int simboloTipoVariableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		String simboloTipoVariable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int constanteleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int constanteright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Boolean constante = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int simboloIdVariableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int simboloIdVariableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String simboloIdVariable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int simbolo_valorleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int simbolo_valorright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimboloValores simbolo_valor = (SimboloValores)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                    // COMPROBACIÓN DE TIPO CORRECTO
                    if (DescripcionValor.dvTipo != tablaSimbolos.consultar(String.valueOf(simboloTipoVariable)).getDescripcionValor()) {
                        String mensajeError = "Excepción en la semántica del lenguaje. Error en la declaración de la variable '" + simboloIdVariable + "'. El tipo debería ser '"+ DescripcionValor.dvTipo + "' pero es '" + tablaSimbolos.consultar(String.valueOf(simboloTipoVariable)).getTipoSubjacenteBasico() + "'" ;
                        gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                        throw new Exception(mensajeError); 
                    }
                    // COMPROBACIÓN TIPO SUBAJCETNE BÁSICO
                    switch(tablaSimbolos.consultar(String.valueOf(simboloTipoVariable)).getTipoSubjacenteBasico()){
                        case tsEntero:case tsBooleano: case tsString:
                            // Comparamos tipo y valor para comprobar que es correcto                   
                            boolean esIdentificador = simbolo_valor.getDescripcionValor() == DescripcionValor.dvVariable || simbolo_valor.getDescripcionValor() == DescripcionValor.dvSubprograma || simbolo_valor.getDescripcionValor() == DescripcionValor.dvArgumento || simbolo_valor.getDescripcionValor() == DescripcionValor.dvConstante;               
                            // COMPROBAMOS SI ES CONSTANTE
                            if (!simbolo_valor.esConstante() && constante){
                                String mensajeError = "Excepción en la semántica del lenguaje. Error al declarar la variable '" + simboloIdVariable + "'. No es constante.";
                                gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                                throw new Exception(mensajeError);                                          
                            }
                            // COMRPOBAMOS QUE EL TIPO DECLARADO SEA CORRECTO
                            if ((DescripcionValor.dvNull == simbolo_valor.getDescripcionValor()) && simbolo_valor.getTipoSubjacenteBasico() != tablaSimbolos.consultar(String.valueOf(simboloTipoVariable)).getTipoSubjacenteBasico()){
                                String mensajeError = "Excepción en la semántica del lenguaje. Error de declaración, '" + simboloIdVariable + "'. No se corresponde al tipod eclarado." + "Tipo de la variable: "+ tablaSimbolos.consultar(String.valueOf(simboloTipoVariable)).getTipoSubjacenteBasico() + ". " + "Tipo del valor: " + simbolo_valor.getTipoSubjacenteBasico() + ".";
                                gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                                throw new Exception(mensajeError);               
                            }
                            // COMPROBAMOS QUE EL TIPO Y EL VALOR ASIGNADO CORRESPONDAN
                            if (esIdentificador && !simboloTipoVariable.equals(simbolo_valor.getNombreTipo())){
                                    String mensajeError = "Excepción en la semántica del lenguaje. Error de declaración, '" + simboloIdVariable + "'. El tipo y el valor asignado no coinciden." + "Tipo de la variable: "+ simboloTipoVariable + ". " + "Tipo del valor: " + simbolo_valor.getNombreTipo() + ".";
                                    gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                                    throw new Exception(mensajeError);                                
                            }                                      
                            
                            int ocupacionVariable = 0;
                            if (simbolo_valor.esString()) {
                                ocupacionVariable = simbolo_valor.getOcupacionString();
                            } else {
                                ocupacionVariable = tablaSimbolos.consultar(String.valueOf(simboloTipoVariable)).getOcupacion();
                            }
                            generadorCodigo3D.getTV().nuevaVariable(simboloIdVariable, generadorCodigo3D.getTP().subprogramaActual(), ocupacionVariable, 0, tablaSimbolos.consultar(String.valueOf(simboloTipoVariable)).getTipoSubjacenteBasico());                           
                            if (!simbolo_valor.esConstante() || !constante) {
                                DescripcionTipo nuevaVariable = new DescripcionTipo(simboloTipoVariable,null, DescripcionValor.dvVariable);
                                nuevaVariable.setIdCodigoIntermedio(generadorCodigo3D.getTV().getNv());
                                tablaSimbolos.poner(simboloIdVariable, nuevaVariable);

                            } else {
                                DescripcionTipo nuevaVariable = new DescripcionTipo(simboloTipoVariable, simbolo_valor.getValorTipo(), DescripcionValor.dvConstante);
                                nuevaVariable.setIdCodigoIntermedio(generadorCodigo3D.getTV().getNv());
                                tablaSimbolos.poner(simboloIdVariable, nuevaVariable);
                            } 

                            // CÓDIGO 3 DIRECCIONES --> INSTRUCCIÓN COPIA SIN OPERANDO 2

                            Operacion3Direcciones copiar =  Operacion3Direcciones.copia;
                            Operador opValor = new Operador(simbolo_valor.getIdVariable(), CategoriaOperador.variable);
                            Operador opVariable = new Operador(String.valueOf(generadorCodigo3D.getTV().getNv()), CategoriaOperador.variable);

                            generadorCodigo3D.generarCodigo3Direcciones(copiar, opValor, null, opVariable);
                            
                            break;
                        default: // Si no es ninguno de los tipos de nuestro programa, lanzamos una excepción
                            String mensajeError = "Excepción en la semántica del lenguaje. Error en la declaración de la siguiente variable: '" + simboloIdVariable + "'. Tipo subjacente básico incorrecto: '" + tablaSimbolos.consultar(String.valueOf(simboloTipoVariable)).getTipoSubjacenteBasico() + "'";
                            gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                            throw new Exception(mensajeError);  
                    }
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECLARACION",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // CONDICIONAL_IF ::= i_if CONDICION_BOOLEANA llave_izq SUMAR_AMBITO M1 INSTRUCCIONES RESTAR_AMBITO llave_der CONDICIONAL_ELSE_IF CONDICIONAL_ELSE 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONDICIONAL_IF",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // CONDICIONAL_ELSE_IF ::= CONDICIONAL_ELSE_IF ETIQUETA_SALTO i_elseif M2 CONDICION_BOOLEANA llave_izq SUMAR_AMBITO M1 INSTRUCCIONES RESTAR_AMBITO llave_der 
            {
              Object RESULT =null;
		int simboloEtiquetaSaltoleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)).left;
		int simboloEtiquetaSaltoright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)).right;
		String simboloEtiquetaSalto = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-9)).value;
		
                    Operador op = new Operador(simboloEtiquetaSalto, CategoriaOperador.etiqueta);
                    // CÓDIGO INTERMEDIO -> ETIQUETA PASAR, NO TIENE OPERANDOS
                    generadorCodigo3D.generarCodigo3Direcciones(Operacion3Direcciones.etiquetaPasar, null, null, op);                
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONDICIONAL_ELSE_IF",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-10)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // CONDICIONAL_ELSE_IF ::= LAMBDA 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONDICIONAL_ELSE_IF",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // CONDICIONAL_ELSE ::= ETIQUETA_SALTO i_else llave_izq SUMAR_AMBITO M2 INSTRUCCIONES RESTAR_AMBITO llave_der 
            {
              Object RESULT =null;
		int simboloEtiquetaSaltoleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int simboloEtiquetaSaltoright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		String simboloEtiquetaSalto = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		
                    Operador op = new Operador(simboloEtiquetaSalto, CategoriaOperador.etiqueta);
                    Operacion3Direcciones instruccion = Operacion3Direcciones.etiquetaPasar;
                    // CÓDIGO INTERMEDIO -> ETIQUETA PASAR SIN OPERANDOS
                    generadorCodigo3D.generarCodigo3Direcciones(instruccion, null, null, op);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONDICIONAL_ELSE",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // CONDICIONAL_ELSE ::= M2 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONDICIONAL_ELSE",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // BUCLE_WHILE ::= i_while ETIQUETA_PASAR CONDICION_BOOLEANA llave_izq SUMAR_AMBITO M1 INSTRUCCIONES RESTAR_AMBITO llave_der 
            {
              Object RESULT =null;
		int simboloEtiquetaleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int simboloEtiquetaright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		String simboloEtiqueta = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		
                // CÓDIGO INTERMEDIO-> ETIQUETA SALTAR SIN OPERANDOS
                // Primero generamos el salto
                Operador opSaltar = new Operador(simboloEtiqueta, CategoriaOperador.etiqueta);
                Operacion3Direcciones saltar = Operacion3Direcciones.saltoIncondicional;
                generadorCodigo3D.generarCodigo3Direcciones(saltar, null, null, opSaltar);
                // Luego la etiqueta
                // CÓDIGO INTERMEDIO-> ETIQUETA PASAR, SIN OPERANDOS
                    Operador opPasar = new Operador(generadorCodigo3D.getPilaFalse().pop(), CategoriaOperador.etiqueta);
                    Operacion3Direcciones pasar = Operacion3Direcciones.etiquetaPasar;
                    generadorCodigo3D.generarCodigo3Direcciones(pasar, null, null, opPasar);
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BUCLE_WHILE",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // LLAMAR_FUNCION ::= i_func PARAMETROS_LLAMADA parentesis_der 
            {
              SimboloFuncion RESULT =null;
		int simboloLlamarleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int simboloLlamarright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimboloParametros simboloLlamar = (SimboloParametros)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
				
            // COMPROBAMOS QUE AL LLAMAR LA FUNCIÓN EL NÚMERO DE PARÁMETROS SEA EL CORRECTO
            if (simboloLlamar.getContador() != numeroParametrosSubprograma(simboloLlamar.getIdSubprograma(),tablaSimbolos.getTablaDescripcion(), tablaSimbolos.getTablaExpansion())){
                String mensajeError = "Excepción en la semántica del lenguaje. Error, el número de parámetros de la función '" + simboloLlamar.getIdSubprograma() + "' es incorrecto." ;
                gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                throw new Exception(mensajeError);
            }
            // CÓDIGO INTERMEDIO --> LLAMADA FUNCIÓN, SIN OPERANDOS
            // ADEMAS ACTUALIZAMOS EL NÚMERO DE PARÁMETROS DE LA TABLA DE PROCEDIMIENTOS/SUBPROGRAMAS
            Operacion3Direcciones llamada = Operacion3Direcciones.llamada;
            Operador opSubprograma = new Operador(String.valueOf(simboloLlamar.getIdCodigo3D()), CategoriaOperador.subprograma);
            generadorCodigo3D.getTP().actualizarNumeroParametros(simboloLlamar.getIdCodigo3D(), simboloLlamar.getContador());                   
            generadorCodigo3D.generarCodigo3Direcciones(llamada,null,null,opSubprograma);

            RESULT = new SimboloFuncion(simboloLlamar.getIdSubprograma(), simboloLlamar.getIdCodigo3D());
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LLAMAR_FUNCION",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // PARAMETROS_LLAMADA ::= PARAMETROS_LLAMADA VALORES 
            {
              SimboloParametros RESULT =null;
		int simboloParametrosleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int simboloParametrosright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimboloParametros simboloParametros = (SimboloParametros)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int simboloValoresleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int simboloValoresright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimboloValores simboloValores = (SimboloValores)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		                    
                    // COMRPOBAMOS EL TIPO SUBJACENTE BÁSICO
                    TipoSubjacenteBasico valor = TipoSubjacenteBasico.tsVoid;
                    if (simboloValores.getDescripcionValor() == DescripcionValor.dvNull) {
                        valor = simboloValores.getTipoSubjacenteBasico();
                        // COMPROBAMOS SI ES ID
                    } else if (esId(simboloValores)) {
                        valor = tablaSimbolos.consultar(simboloValores.getNombreTipo()).getTipoSubjacenteBasico();
                    } else {
                        String mensajeError = "Excepción en la semántica del lenguaje. Error en la llamada de la siguiente función:'" + simboloParametros.getIdSubprograma() + "'.Descripción valor incorrecto: "+ simboloValores.getDescripcionValor() + ".";
                        gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                        throw new Exception(mensajeError);
                    }
                    // COMPROBAMOS TIPO SUBYACENTE DE LA FUNCIÓN
                    if (valor != tablaSimbolos.consultar(tipoParametro(simboloParametros.getIdSubprograma(), simboloParametros.getContador(), tablaSimbolos.getTablaDescripcion(), tablaSimbolos.getTablaExpansion()).getNombreId()).getTipoSubjacenteBasico()) {
                        String mensajeError = "Excepción en la semántica del lenguaje. Tipo subjacente erroneo en la función: '" + simboloParametros.getIdSubprograma();
                        gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                        throw new Exception(mensajeError);
                    }
                    // CÓDIGO INTERMEDIO-> PARAMETRO DE LA FUNCIÓN
                    Operador variable= new Operador(String.valueOf(simboloValores.getIdVariable()), CategoriaOperador.variable);
                    Operador parametro = new Operador(String.valueOf(simboloParametros.getContador() + 1), CategoriaOperador.nParametro);
                    Operador subprograma = new Operador(String.valueOf(simboloParametros.getIdCodigo3D()), CategoriaOperador.subprograma);
                    generadorCodigo3D.generarCodigo3Direcciones(Operacion3Direcciones.parametroSimple,variable,parametro,subprograma);

                    RESULT = new SimboloParametros(simboloParametros.getIdSubprograma(), simboloParametros.getContador() + 1, simboloParametros.getIdCodigo3D());
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMETROS_LLAMADA",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // PARAMETROS_LLAMADA ::= identificador parentesis_izq 
            {
              SimboloParametros RESULT =null;
		int simboloIdFuncionleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int simboloIdFuncionright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String simboloIdFuncion = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                    RESULT = new SimboloParametros(simboloIdFuncion, 0, tablaSimbolos.consultar(simboloIdFuncion).getIdCodigoIntermedio());
                
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMETROS_LLAMADA",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // SALIDA_DATOS ::= i_stdout parentesis_izq VALORES parentesis_der fin_instruccion 
            {
              Object RESULT =null;
		int simbolo_valorleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int simbolo_valorright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SimboloValores simbolo_valor = (SimboloValores)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
                    // COMRPOBAMOS QUE EL TIPO SUBYACENTE BÁSICO DEL VALOR SEA EL ADECUADO
                    if (!esTipoSubjacenteBasico(simbolo_valor)) {
                        String mensajeError = "Excepción en la semántica del lenguaje. Error en la operaciónd de salida de datos: " + simbolo_valor.getDescripcionValor() + ".";
                        gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                        throw new Exception(mensajeError);
                    }
                    // CÓDIGO INTERMEDIO-> SALIDA ESTÁNDAR DE DATOS
                    Operacion3Direcciones opSalida = Operacion3Direcciones.salidaDatos;
                    Operador op = new Operador(String.valueOf(simbolo_valor.getIdVariable()), CategoriaOperador.variable);
                    generadorCodigo3D.generarCodigo3Direcciones(opSalida, null, null, op);
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SALIDA_DATOS",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // INICIALIZAR_OPERADOR_ARITMETICO ::= parentesis_izq OPERACION_ARITMETICA parentesis_der 
            {
              SimboloOperadores RESULT =null;
		int simboloOperacionAritleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int simboloOperacionAritright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimboloOperadores simboloOperacionArit = (SimboloOperadores)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                        // GUARDAMOS LOS VALORES DE LA OPERACIÓN ARITMÉTICA
                        if (simboloOperacionArit.esConstante()) {
                            RESULT =  new SimboloOperadores(simboloOperacionArit.getIdVariable(),simboloOperacionArit.esConstante(), simboloOperacionArit.getValorTipo());
                        }else{
                            RESULT =  new SimboloOperadores(simboloOperacionArit.getIdVariable(),simboloOperacionArit.esConstante());
                        }
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INICIALIZAR_OPERADOR_ARITMETICO",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // OPERACION_ARITMETICA ::= OPERACION_ARITMETICA operador_aritmetico VALOR_OPERACION_ARITMETICA 
            {
              SimboloOperadores RESULT =null;
		int valorOpAritleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int valorOpAritright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SimboloOperadores valorOpArit = (SimboloOperadores)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int operador_aritmeticoleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int operador_aritmeticoright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String operador_aritmetico = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int valOperacionAritleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int valOperacionAritright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimboloOperadores valOperacionArit = (SimboloOperadores)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                        SimboloOperadores operadorAritmetico2 = new SimboloOperadores();
                        if (operadorAritmetico2.esConstante() && valOperacionArit.esConstante()) {
                            operadorAritmetico2.setEsConstante(true);
                            operadorAritmetico2.setValorTipo(realizarOperacion(operador_aritmetico, (int) valorOpArit.getValorTipo(), (int) valOperacionArit.getValorTipo()));
                        }
                        // CÓDIGO INTERMEDIO, GENERAMOS VARIABLE TEMPORAL
                        generadorCodigo3D.getTV().nuevaVariable("Variable temporal", generadorCodigo3D.getTP().subprogramaActual(), tablaSimbolos.consultar("int").getOcupacion(), 0, tablaSimbolos.consultar("int").getTipoSubjacenteBasico());
                        operadorAritmetico2.setIdVariable(String.valueOf(generadorCodigo3D.getTV().getNv()));
                        // Código 3 direcciones
                        Operador opVariable = new Operador(valorOpArit.getIdVariable(), CategoriaOperador.variable);
                        Operador opVariable2 = new Operador(valOperacionArit.getIdVariable(), CategoriaOperador.variable);
                        Operador variableTemporal = new Operador(String.valueOf(generadorCodigo3D.getTV().getNv()), CategoriaOperador.variable);
                        // CÓDIGO INTERMEDIO DEL OPERADOS ARITMETICO
                        generadorCodigo3D.generarCodigo3Direcciones(indicarOperador(operador_aritmetico), opVariable, opVariable2,variableTemporal);
                        RESULT = operadorAritmetico2;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OPERACION_ARITMETICA",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // OPERACION_ARITMETICA ::= VALOR_OPERACION_ARITMETICA operador_aritmetico VALOR_OPERACION_ARITMETICA 
            {
              SimboloOperadores RESULT =null;
		int valOperacionArit1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int valOperacionArit1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SimboloOperadores valOperacionArit1 = (SimboloOperadores)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int operador_aritmeticoleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int operador_aritmeticoright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String operador_aritmetico = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int valOperacionArit2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int valOperacionArit2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimboloOperadores valOperacionArit2 = (SimboloOperadores)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                        SimboloOperadores operadorAritmetico = new SimboloOperadores();
                        if (valOperacionArit1.esConstante() && valOperacionArit2.esConstante()) {
                            operadorAritmetico.setEsConstante(true);
                            operadorAritmetico.setValorTipo(realizarOperacion(operador_aritmetico, (int) valOperacionArit1.getValorTipo(), (int) valOperacionArit2.getValorTipo()));
                        }
                        // CÓDIGO INTERMEDIO, GENERAMOS VARIABLE TEMPORAL
                        generadorCodigo3D.getTV().nuevaVariable("Variable temporal", generadorCodigo3D.getTP().subprogramaActual(), tablaSimbolos.consultar("int").getOcupacion(), 0, tablaSimbolos.consultar("int").getTipoSubjacenteBasico());
                        operadorAritmetico.setIdVariable(String.valueOf(generadorCodigo3D.getTV().getNv()));
                        // Código 3 direcciones
                        Operador opVar = new Operador(valOperacionArit1.getIdVariable(), CategoriaOperador.variable);
                        Operador opVar2 = new Operador(valOperacionArit2.getIdVariable(), CategoriaOperador.variable);
                        Operador opVarTemporal = new Operador(String.valueOf(generadorCodigo3D.getTV().getNv()), CategoriaOperador.variable);
                        // CÓDIGO INTERMEDIO DEL OPERADOS ARITMETICO
                        generadorCodigo3D.generarCodigo3Direcciones(indicarOperador(operador_aritmetico), opVar, opVar2,  opVarTemporal);
                        RESULT = operadorAritmetico;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OPERACION_ARITMETICA",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // VALOR_OPERACION_ARITMETICA ::= parentesis_izq OPERACION_ARITMETICA parentesis_der 
            {
              SimboloOperadores RESULT =null;
		int simboloOperacionleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int simboloOperacionright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimboloOperadores simboloOperacion = (SimboloOperadores)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                        if (simboloOperacion.esConstante()) {
                            RESULT = new SimboloOperadores(simboloOperacion.getIdVariable(),simboloOperacion.esConstante(), simboloOperacion.getValorTipo());
                        }else{
                            RESULT =  new SimboloOperadores(simboloOperacion.getIdVariable(),simboloOperacion.esConstante());
                        }
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALOR_OPERACION_ARITMETICA",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // VALOR_OPERACION_ARITMETICA ::= identificador 
            {
              SimboloOperadores RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        // CONTENIDO ERRONEO
                        if (esTipoDescripcion(tablaSimbolos.consultar(id))) {
                            String mensajeError = "Excepción en la semántica del lenguaje. Operador aritmético: '" + id + "'. El valor tiene un contenido erroneo: " + tablaSimbolos.consultar(id).getDescripcionValor() + ".";
                            gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                            throw new Exception(mensajeError);                         
                        }
                        // TIPO SUBYACENTE ERRONEO
                        if (TipoSubjacenteBasico.tsEntero != tablaSimbolos.consultar(tablaSimbolos.consultar(id).getNombreId()).getTipoSubjacenteBasico()){
                            String mensajeError = "Excepción en la semántica del lenguaje. Operador aritmético '" + id + "'. Tipo Subjacente erroneo del valor: " + tablaSimbolos.consultar(tablaSimbolos.consultar(id).getNombreId()).getTipoSubjacenteBasico() + ".";
                            gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                            throw new Exception(mensajeError); 
                        }
                        if (DescripcionValor.dvConstante == tablaSimbolos.consultar(id).getDescripcionValor()) {                        
                            RESULT = new SimboloOperadores(String.valueOf(tablaSimbolos.consultar(id).getIdCodigoIntermedio()), true, (int) tablaSimbolos.consultar(id).getValorConstante());
                        }else{
                            RESULT = new SimboloOperadores(String.valueOf(tablaSimbolos.consultar(id).getIdCodigoIntermedio()), false);
                        }
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALOR_OPERACION_ARITMETICA",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // VALOR_OPERACION_ARITMETICA ::= SIGNO entero 
            {
              SimboloOperadores RESULT =null;
		int simbolo_signoleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int simbolo_signoright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimboloValores simbolo_signo = (SimboloValores)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int entero_valorleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int entero_valorright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String entero_valor = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                        // CÓDIGO INTERMEDIO, GENERAMOS VARIABLE TEMPORAL Y INSTRUCCION 3D DE COPIA
                        generadorCodigo3D.getTV().nuevaVariable("Variable temporal", generadorCodigo3D.getTP().subprogramaActual(), tablaSimbolos.consultar("int").getOcupacion(), 0, tablaSimbolos.consultar("int").getTipoSubjacenteBasico());
                        if(simbolo_signo != null && simbolo_signo.esNegativo()){                        
                            generadorCodigo3D.generarCodigo3Direcciones(Operacion3Direcciones.copia, new Operador(String.valueOf(-Integer.parseInt(entero_valor)), CategoriaOperador.valorAritmetico), null, new Operador(String.valueOf(generadorCodigo3D.getTV().getNv()), CategoriaOperador.variable));
                            RESULT = new SimboloOperadores(String.valueOf(generadorCodigo3D.getTV().getNv()),-Integer.parseInt(entero_valor));
                        }else{                       
                            generadorCodigo3D.generarCodigo3Direcciones(Operacion3Direcciones.copia, new Operador(String.valueOf(Integer.parseInt(entero_valor)), CategoriaOperador.valorAritmetico), null, new Operador(String.valueOf(generadorCodigo3D.getTV().getNv()), CategoriaOperador.variable));
                            RESULT = new SimboloOperadores(String.valueOf(generadorCodigo3D.getTV().getNv()),Integer.parseInt(entero_valor));
                        }
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALOR_OPERACION_ARITMETICA",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // SIGNO ::= operador_aritmetico 
            {
              SimboloValores RESULT =null;
		int simboloOperacionleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int simboloOperacionright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String simboloOperacion = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                // COMRPOBACIÓN DE QUE EL SIGNO CORRESPONDA CON EL MENOS O EL MÁS
                if (!simboloOperacion.equals("+") && !simboloOperacion.equals("-")){
                    String mensajeError = "Excepción en la semántica del lenguaje de tipo operador incorrecto, el signo debería ser '+' o '-'.";
                    gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                    throw new Exception(mensajeError);
                }
                if (!simboloOperacion.equals("-")) {
                    RESULT = new SimboloValores(false);
                }else{
                    RESULT = new SimboloValores(true);
                }
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SIGNO",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // SIGNO ::= 
            {
              SimboloValores RESULT =null;
		 
           
                RESULT = new SimboloValores();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SIGNO",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // CONSTANTE ::= constante 
            {
              Boolean RESULT =null;
		
       
                    RESULT = true;

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONSTANTE",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // CONSTANTE ::= 
            {
              Boolean RESULT =null;
		
                    RESULT = false;

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONSTANTE",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // INICIALIZAR_OPERADOR_BOOLEANO ::= parentesis_izq OPERACION_BOOLEANA parentesis_der 
            {
              SimboloOperadores RESULT =null;
		int operacion_booleanaleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int operacion_booleanaright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimboloOperadores operacion_booleana = (SimboloOperadores)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                        if (!operacion_booleana.esSimple()) generadorCodigo3D.generarCodigo3Direcciones(Operacion3Direcciones.etiquetaPasar, null, null, new Operador(operacion_booleana.getIdEtiqueta(), CategoriaOperador.etiqueta));
                        if (operacion_booleana.esConstante()) {
                            RESULT = new SimboloOperadores(operacion_booleana.getIdVariable(), true, operacion_booleana.getValorTipo());
                        }else{
                            RESULT = new SimboloOperadores(operacion_booleana.getIdVariable());
                        }
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INICIALIZAR_OPERADOR_BOOLEANO",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // OPERACION_BOOLEANA ::= OPERACION_BOOLEANA operador_logico VALOR_OPERACION_BOOLEANA 
            {
              SimboloOperadores RESULT =null;
		int operador_bool1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int operador_bool1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SimboloOperadores operador_bool1 = (SimboloOperadores)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int operador_logicoleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int operador_logicoright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String operador_logico = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int operador_bool2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int operador_bool2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimboloOperadores operador_bool2 = (SimboloOperadores)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        // MIRAMOS EL OPERADOR LÓGICO Y SEGÚN SEA GENERAMOS INSTRUCCION CONDICIONAL FALSA Y INSTRUCCION AND
                        if(operador_logico.equals("&")){
                            generadorCodigo3D.generarCodigo3Direcciones(Operacion3Direcciones.esFalse, new Operador(String.valueOf(operador_bool1.getIdVariable()), CategoriaOperador.variable), null, new Operador(String.valueOf(operador_bool1.getIdEtiqueta()), CategoriaOperador.etiqueta));
                            generadorCodigo3D.generarCodigo3Direcciones(Operacion3Direcciones.and, new Operador(String.valueOf(operador_bool2.getIdVariable()), CategoriaOperador.variable), null, new Operador(String.valueOf(operador_bool1.getIdVariable()), CategoriaOperador.variable));      

                        // MIRAMOS EL OPERADOR LÓGICO Y SEGÚN SEA GENERAMOS INSTRUCCION CONDICIONAL VERDADERA Y INSTRUCCION OR                     
                        }else if(operador_logico.equals("|")){
                            generadorCodigo3D.generarCodigo3Direcciones(Operacion3Direcciones.esTrue, new Operador(String.valueOf(operador_bool1.getIdVariable()), CategoriaOperador.variable), null, new Operador(String.valueOf(operador_bool1.getIdEtiqueta()), CategoriaOperador.etiqueta));
                            generadorCodigo3D.generarCodigo3Direcciones(Operacion3Direcciones.or, new Operador(String.valueOf(operador_bool2.getIdVariable()), CategoriaOperador.variable), null, new Operador(String.valueOf(operador_bool1.getIdVariable()), CategoriaOperador.variable));               
                        }
                        SimboloOperadores simboloOperacionBooleana = new SimboloOperadores(operador_bool1.getIdEtiqueta(), operador_bool1.getIdVariable(), false);
                        if (operador_bool2.esConstante() && operador_bool1.esConstante()) {
                            simboloOperacionBooleana.setEsConstante(true); 
                            if(operador_logico.equals("&")){
                                simboloOperacionBooleana.setValorTipo((boolean) operador_bool1.getValorTipo() && (boolean) operador_bool2.getValorTipo());
                            }else if(operador_logico.equals("|")){
                                simboloOperacionBooleana.setValorTipo((boolean) operador_bool1.getValorTipo() || (boolean) operador_bool2.getValorTipo());
                            }

                        }
                        RESULT = simboloOperacionBooleana;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OPERACION_BOOLEANA",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // OPERACION_BOOLEANA ::= VALOR_OPERACION_BOOLEANA 
            {
              SimboloOperadores RESULT =null;
		int op_bool_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int op_bool_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimboloOperadores op_bool_value = (SimboloOperadores)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        // GENERAMOS UNA ETIQUETA DE SALTO
                        generadorCodigo3D.getTablaEtiquetas().add("ETIQUETA" + generadorCodigo3D.getNumeroEtiqueta());
                        generadorCodigo3D.sumarEtiqueta();

                        if (op_bool_value.esConstante()) {
                            RESULT = new SimboloOperadores(true, op_bool_value.getValorTipo(), true, String.valueOf(generadorCodigo3D.getNumeroEtiqueta()), op_bool_value.getIdVariable());
                        }else{
                            RESULT = new SimboloOperadores(true,String.valueOf(generadorCodigo3D.getNumeroEtiqueta()), op_bool_value.getIdVariable() );
                        }
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OPERACION_BOOLEANA",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // VALOR_OPERACION_BOOLEANA ::= parentesis_izq OPERACION_BOOLEANA parentesis_der 
            {
              SimboloOperadores RESULT =null;
		int op_booleanleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int op_booleanright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimboloOperadores op_boolean = (SimboloOperadores)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                        generadorCodigo3D.generarCodigo3Direcciones(Operacion3Direcciones.etiquetaPasar, null, null, new Operador(String.valueOf(op_boolean.getIdEtiqueta()), CategoriaOperador.variable));                         
                        if (op_boolean.esConstante()) {
                            RESULT = new SimboloOperadores(true, op_boolean.getValorTipo(),op_boolean.getIdVariable());
                        }else{
                            RESULT = new SimboloOperadores(op_boolean.getIdVariable());
                        }
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALOR_OPERACION_BOOLEANA",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // VALOR_OPERACION_BOOLEANA ::= booleano 
            {
              SimboloOperadores RESULT =null;
		int bool_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int bool_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String bool_val = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                        // GENERAMOS UNA VARIABLE TEMPORAL
                        generadorCodigo3D.getTV().nuevaVariable("Variable temporal", generadorCodigo3D.getTP().subprogramaActual(), tablaSimbolos.consultar("bool").getOcupacion(), 0, tablaSimbolos.consultar("bool").getTipoSubjacenteBasico());
                        // CÓDIGO INTERMEDIO  
                        Operacion3Direcciones opCopia =  Operacion3Direcciones.copia;
                        Operador opBool = new Operador(bool_val, CategoriaOperador.valorBooleano);
                        Operador opVarTemp = new Operador(String.valueOf(generadorCodigo3D.getTV().getNv()), CategoriaOperador.variable);
                        // CÓDIGO INTERMEDIO  INSTRUCCION COPIA
                        generadorCodigo3D.generarCodigo3Direcciones(opCopia,opBool,null,opVarTemp);
                        RESULT = new SimboloOperadores(String.valueOf(generadorCodigo3D.getTV().getNv()),Boolean.parseBoolean(bool_val));                    
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALOR_OPERACION_BOOLEANA",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // VALOR_OPERACION_BOOLEANA ::= OPERACION_RELACIONAL 
            {
              SimboloOperadores RESULT =null;
		int simboloComparadorleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int simboloComparadorright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimboloOperadores simboloComparador = (SimboloOperadores)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        RESULT =  new SimboloOperadores(simboloComparador.getIdVariable());
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALOR_OPERACION_BOOLEANA",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // VALOR_OPERACION_BOOLEANA ::= identificador 
            {
              SimboloOperadores RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        // CONSULTAMOS LA DESCRIPCION VALOR DEL IDENTIFICADOR, MIRAMOS QUE SE AUNA VARIABLE, CONSTANTE O ARGUMENTO
                        switch(tablaSimbolos.consultar(id).getDescripcionValor()){
                            case dvVariable: case dvArgumento: case dvConstante:
                                // COMRPOBACION TIPO SUBYACENTE
                                if (TipoSubjacenteBasico.tsBooleano != tablaSimbolos.consultar(tablaSimbolos.consultar(id).getNombreId()).getTipoSubjacenteBasico()){
                                    String mensajeError = "Excepción en la semántica del lenguaje. No es del tipo subjacente adecuado. Debería ser un booleano " + tablaSimbolos.consultar(tablaSimbolos.consultar(id).getNombreId()).getTipoSubjacenteBasico() + ".";
                                    gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                                    throw new Exception(mensajeError);
                                }
                                if (DescripcionValor.dvConstante == tablaSimbolos.consultar(id).getDescripcionValor()) {
                                    RESULT = new SimboloOperadores( true, tablaSimbolos.consultar(id).getValorConstante(), String.valueOf(tablaSimbolos.consultar(id).getIdCodigoIntermedio()));
                                }else{
                                    RESULT = new SimboloOperadores(String.valueOf(tablaSimbolos.consultar(id).getIdCodigoIntermedio()));
                                }                                
                                break;
                            default:
                            String mensajeError = "Excepción en la semántica del lenguaje. El valor booleano no tiene la descripción de valor adecuada: " + tablaSimbolos.consultar(id).getDescripcionValor() + ".";
                            gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                            throw new Exception(mensajeError); 
                        }
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALOR_OPERACION_BOOLEANA",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // OPERACION_RELACIONAL ::= VALORES operador_relacional VALORES 
            {
              SimboloOperadores RESULT =null;
		int value_1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int value_1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SimboloValores value_1 = (SimboloValores)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int op_relationalleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int op_relationalright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String op_relational = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int value_2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int value_2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimboloValores value_2 = (SimboloValores)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        // COMRPOBAMOS LOS POSIBLES ERRORES DEL VALOR 1
                        TipoSubjacenteBasico valor1 = comprobarValores (value_1);
                        // HACEMOS LO MISMO PERO AHORA CON EL VALOR 2
                        TipoSubjacenteBasico valor2 = comprobarValores (value_2);
                        // Comprobamos que el tipo subjacente básico de ámbos coincida
                        if (valor1 != valor2) {
                            String mensajeError = "Excepción en la semántica del lenguaje. Ambos valores tienen tipos subjacente básicos distintos. Tipo subjacente básico valor 1: " + valor1 +"Tipo subjacente básico valor 2: " + valor2;
                            gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                            throw new Exception(mensajeError);
                        }
                        boolean esOperadorRelacional= op_relational.equals(">")|| op_relational.equals(">=")|| op_relational.equals("<")|| op_relational.equals("<=");
                        if (esOperadorRelacional && (TipoSubjacenteBasico.tsEntero != valor1)){
                            String mensajeError = "Excepción en la semántica del lenguaje. Error, el operador: '" + op_relational + "' no compara tipos subjacentes básicos:" + valor1;
                            gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                            throw new Exception(mensajeError);           
                        }
                        SimboloOperadores comparacionRelacional = new SimboloOperadores();
                        if (value_1.esConstante() && value_2.esConstante()) {
                            switch (op_relational) {
                                case ">":comparacionRelacional.setValorTipo(((int) value_1.getValorTipo()) > ((int) value_2.getValorTipo()));break;
                                case ">=":comparacionRelacional.setValorTipo(((int) value_1.getValorTipo()) >= ((int) value_2.getValorTipo()));break;
                                case "<":comparacionRelacional.setValorTipo(((int) value_1.getValorTipo()) < ((int) value_2.getValorTipo()));break;
                                case "<=":comparacionRelacional.setValorTipo(((int) value_1.getValorTipo()) <= ((int) value_2.getValorTipo()));break;
                                case "==":
                                    switch (valor1) {
                                        case tsEntero:comparacionRelacional.setValorTipo(((int) value_1.getValorTipo()) == ((int) value_2.getValorTipo()));break;
                                        case tsString:comparacionRelacional.setValorTipo((String.valueOf(value_1.getValorTipo())).equals(String.valueOf(value_2.getValorTipo())));break;
                                        case tsBooleano:comparacionRelacional.setValorTipo(((boolean) value_1.getValorTipo()) == ((boolean) value_2.getValorTipo()));
                                    }
                                case "!=":
                                    switch (valor1) {
                                        case tsEntero:comparacionRelacional.setValorTipo(((int) value_1.getValorTipo()) != ((int) value_2.getValorTipo()));break;
                                        case tsString:comparacionRelacional.setValorTipo( !(String.valueOf(value_1.getValorTipo())).equals(String.valueOf(value_2.getValorTipo())));break;
                                        case tsBooleano:comparacionRelacional.setValorTipo (((boolean) value_1.getValorTipo()) != ((boolean) value_2.getValorTipo()));
                                    }
                            }
                            comparacionRelacional.setEsConstante(true);
                        }
                        // GENERAMOS INSTRUCCION CODIGO 3D SEGUN EL OPERADOR RELACIONAL QUE TOQUE
                        if (TipoSubjacenteBasico.tsBooleano == valor1) {
                            generadorCodigo3D.getTV().nuevaVariable("Variable temporal", generadorCodigo3D.getTP().subprogramaActual(), tablaSimbolos.consultar("bool").getOcupacion(), 0, tablaSimbolos.consultar("bool").getTipoSubjacenteBasico());
                            comparacionRelacional.setIdVariable(String.valueOf(generadorCodigo3D.getTV().getNv()));
                            generadorCodigo3D.generarCodigo3Direcciones(comprobarOperadorRelacional(op_relational), new Operador(value_1.getIdVariable(), CategoriaOperador.valorBooleano), new Operador(value_2.getIdVariable(), CategoriaOperador.valorBooleano), new Operador(String.valueOf(generadorCodigo3D.getTV().getNv()), CategoriaOperador.variable));
                            RESULT = comparacionRelacional;
                        } else if (TipoSubjacenteBasico.tsEntero == valor1) {
                            generadorCodigo3D.getTV().nuevaVariable("Variable temporal", generadorCodigo3D.getTP().subprogramaActual(), tablaSimbolos.consultar("bool").getOcupacion(), 0, tablaSimbolos.consultar("bool").getTipoSubjacenteBasico());
                            comparacionRelacional.setIdVariable(String.valueOf(generadorCodigo3D.getTV().getNv()));
                            generadorCodigo3D.generarCodigo3Direcciones(comprobarOperadorRelacional(op_relational), new Operador(value_1.getIdVariable(), CategoriaOperador.valorAritmetico), new Operador(value_2.getIdVariable(), CategoriaOperador.valorAritmetico), new Operador(String.valueOf(generadorCodigo3D.getTV().getNv()), CategoriaOperador.variable));
                            RESULT = comparacionRelacional;
                        }

                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OPERACION_RELACIONAL",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // CONDICION_BOOLEANA ::= INICIALIZAR_OPERADOR_BOOLEANO 
            {
              Object RESULT =null;
		int inicializar_operadorleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int inicializar_operadorright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimboloOperadores inicializar_operador = (SimboloOperadores)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // CÓDIGO INTERMEDIO, SEGENERAN ETIQUETAS DE SALTO PARA LA CONDICIÓN
                    generadorCodigo3D.getTablaEtiquetas().add("ETIQUETA" + generadorCodigo3D.getNumeroEtiqueta());
                    generadorCodigo3D.sumarEtiqueta();
                    generadorCodigo3D.getPilaTrue().push(String.valueOf(generadorCodigo3D.getNumeroEtiqueta()));
                    // INSTRUCCIÓN DE EVALUACIÓN VERDADERA
                    generadorCodigo3D.generarCodigo3Direcciones(Operacion3Direcciones.esTrue, new Operador(inicializar_operador.getIdVariable(),CategoriaOperador.variable), null, new Operador(String.valueOf(generadorCodigo3D.getNumeroEtiqueta()), CategoriaOperador.etiqueta));
                    generadorCodigo3D.getTablaEtiquetas().add("ETIQUETA" + generadorCodigo3D.getNumeroEtiqueta());
                    generadorCodigo3D.sumarEtiqueta();
                    generadorCodigo3D.getPilaFalse().push(String.valueOf(generadorCodigo3D.getNumeroEtiqueta()));
                    // INSTRUCCIÓN DE EVALUACIÓN FALSA
                    generadorCodigo3D.generarCodigo3Direcciones(Operacion3Direcciones.esFalse, new Operador(inicializar_operador.getIdVariable(), CategoriaOperador.variable), null, new Operador(String.valueOf(generadorCodigo3D.getNumeroEtiqueta()), CategoriaOperador.etiqueta));            
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONDICION_BOOLEANA",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // ETIQUETA_SALTO ::= LAMBDA 
            {
              String RESULT =null;
		
                   // CÓDIGO INTERMEDIO, GENERAMOS ETIQUETA SALTO Y INSTRUCCIÓN DE SALTO
                   generadorCodigo3D.getTablaEtiquetas().add("ETIQUETA" + generadorCodigo3D.getNumeroEtiqueta());
                   generadorCodigo3D.sumarEtiqueta();
                   generadorCodigo3D.generarCodigo3Direcciones(Operacion3Direcciones.saltoIncondicional, null, null, new Operador(String.valueOf(generadorCodigo3D.getNumeroEtiqueta()), CategoriaOperador.etiqueta));
                   RESULT = (String.valueOf(generadorCodigo3D.getNumeroEtiqueta()));
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ETIQUETA_SALTO",29, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // CREAR_FUNCION ::= CREAR_FUNCION INICIO_FUNCION parentesis_der llave_izq SUMAR_AMBITO INSTRUCCIONES RETURN RESTAR_AMBITO llave_der 
            {
              Object RESULT =null;
		int simboloFuncionleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int simboloFuncionright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		SimboloFuncion simboloFuncion = (SimboloFuncion)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		int simboloRetornoleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int simboloRetornoright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SimboloFuncion simboloRetorno = (SimboloFuncion)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
                    // COMPROBACIÓN DEL SÍMBOLO RETORNO, SI EL VALOR ES CORRECTO
                    Operador numSubprograma = new Operador(String.valueOf(simboloFuncion.getnSubprograma()), CategoriaOperador.subprograma);
                    if (simboloRetorno != null ) {
                        if (tablaSimbolos.consultar(simboloFuncion.getSubprograma()).getTipoSubjacenteBasico() != simboloRetorno.getTipoSubjacenteBasico()){
                            String mensajeError = "Excepción en la semántica del lenguaje. Valor incorrecto de retorno.";
                            gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                            throw new Exception(mensajeError);  
                        }
                        // CÓDIGO INTERMEDIO, INSTRUCCION DE RETORNO DE UNA FUNCION
                        Operacion3Direcciones retorno = Operacion3Direcciones.retorno;
                        Operador valorRetorno = new Operador(String.valueOf(simboloRetorno.getIdCodigo3D()), CategoriaOperador.variable);
                        generadorCodigo3D.generarCodigo3Direcciones(retorno, numSubprograma, null, valorRetorno);
                    } else {              
                        // ERROR DE QUE EL TIPO SEA VOID PERO NO HAYA RETORNO
                         if (TipoSubjacenteBasico.tsVoid != tablaSimbolos.consultar(simboloFuncion.getSubprograma()).getTipoSubjacenteBasico()) {
                            String mensajeError = "Excepción en la semántica del lenguaje. Falta el retorno de la función.";
                            gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                            throw new Exception(mensajeError);      
                        }
                    }
                    // INSTRUCCION DE FIN DE PROGRAMA
                    Operacion3Direcciones finprograma = Operacion3Direcciones.finSubprograma;
                    generadorCodigo3D.generarCodigo3Direcciones(finprograma, null, null, numSubprograma);
                    
                    if(simboloFuncion.getNombreSubprograma().equals("Principal") ){
                       generadorCodigo3D.generarCodigo3DireccionesPrincipal(Operacion3Direcciones.llamadaMain, null, null, new Operador(String.valueOf(tablaSimbolos.consultar("Principal").getIdCodigoIntermedio()), CategoriaOperador.subprograma));        
                    }
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CREAR_FUNCION",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // CREAR_FUNCION ::= LAMBDA 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CREAR_FUNCION",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // INICIO_FUNCION ::= i_func identificador identificador parentesis_izq PARAMETROS_FUNCION 
            {
              SimboloFuncion RESULT =null;
		int simboloTipoVariableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int simboloTipoVariableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String simboloTipoVariable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int simboloIdFuncionleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int simboloIdFuncionright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String simboloIdFuncion = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int simboloParametrosleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int simboloParametrosright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimboloParametros simboloParametros = (SimboloParametros)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // comprobamos que el tipo es correcto
                    if (DescripcionValor.dvTipo != tablaSimbolos.consultar(String.valueOf(simboloTipoVariable)).getDescripcionValor()) {
                        String mensajeError = "Excepción en la semántica del lenguaje. No es del tipo adecuado.";
                        gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                        throw new Exception(mensajeError);
                    }  
                    comprobarErrorTipoSubjacenteBasico(String.valueOf(simboloTipoVariable));                  
                    generadorCodigo3D.getTP().nuevoSubprograma(simboloIdFuncion, tablaSimbolos.getAmbitoActual(), 0, tablaSimbolos.consultar(String.valueOf(simboloTipoVariable)).getOcupacion(), tablaSimbolos.consultar(String.valueOf(simboloTipoVariable)).getTipoSubjacenteBasico());
                    // Si ha pasado el filtro anterior, la añadimos a nuestra tabla de descripciones
                    tablaSimbolos.poner(simboloIdFuncion, new DescripcionTipo(simboloTipoVariable, null,DescripcionValor.dvSubprograma, generadorCodigo3D.getTP().getNp()));
                    // Añadimos los parámetros de la función a la tabla de expansión
                    if(simboloParametros != null){
                        for (int i = 0; i < simboloParametros.getListaVariables().size(); i++) {
                            generadorCodigo3D.getTV().nuevaVariable(simboloParametros.getListaVariables().get(i), generadorCodigo3D.getTP().subprogramaActual(), tablaSimbolos.consultar(simboloParametros.getListaTipoDescripcion().get(i).getNombreId()).getOcupacion(), -1, tablaSimbolos.consultar(simboloParametros.getListaTipoDescripcion().get(i).getNombreId()).getTipoSubjacenteBasico());
                            simboloParametros.getListaTipoDescripcion().get(i).setIdCodigoIntermedio(generadorCodigo3D.getTV().getNv());
                            tablaSimbolos.ponerParametro(simboloIdFuncion, simboloParametros.getListaVariables().get(i), simboloParametros.getListaTipoDescripcion().get(i));                           
                        }
                    }
                    // CÓDIGO INTERMEDIO-> INSTRUCCION SUBPROGRAMA E INSTRUCCION INCIALIZAR SUBPROGRMAA
                    Operador opSubprograma = new Operador(String.valueOf(generadorCodigo3D.getTP().getNp()), CategoriaOperador.subprograma);
                    Operacion3Direcciones idSubprograma = Operacion3Direcciones.idSubprograma;
                    generadorCodigo3D.generarCodigo3Direcciones(idSubprograma, null, null, opSubprograma);
                    Operacion3Direcciones inicializar = Operacion3Direcciones.inicializacion;
                    generadorCodigo3D.generarCodigo3Direcciones(inicializar, null, null, opSubprograma);
                    RESULT = new SimboloFuncion(simboloTipoVariable, generadorCodigo3D.getTP().getNp(),simboloIdFuncion);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INICIO_FUNCION",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // PARAMETROS_FUNCION ::= MAS_PARAMETROS 
            {
              SimboloParametros RESULT =null;
		int simboloParametrosleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int simboloParametrosright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimboloParametros simboloParametros = (SimboloParametros)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                RESULT = new SimboloParametros(simboloParametros.getListaVariables(), simboloParametros.getListaTipoDescripcion());
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMETROS_FUNCION",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // PARAMETROS_FUNCION ::= 
            {
              SimboloParametros RESULT =null;
		
                RESULT = new SimboloParametros();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMETROS_FUNCION",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // MAS_PARAMETROS ::= MAS_PARAMETROS coma identificador identificador 
            {
              SimboloParametros RESULT =null;
		int simboloParametrosleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int simboloParametrosright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		SimboloParametros simboloParametros = (SimboloParametros)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int simboloTipoVariableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int simboloTipoVariableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String simboloTipoVariable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int simboloIdVariableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int simboloIdVariableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String simboloIdVariable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // Comprobación del tipo del parámetro
                    if (DescripcionValor.dvTipo != tablaSimbolos.consultar(String.valueOf(simboloTipoVariable)).getDescripcionValor()){
                        String mensajeError = "Excepción en la semántica del lenguaje. Error, el tipo del parámetro es incorrecto.";
                        gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                        throw new Exception(mensajeError);                   
                    }
                    // Consultamos en la tabla de simbolos el símbolo del tipo de variable y comprobamos si el tipo es correcto
                    comprobarErrorTipoSubjacenteBasico(String.valueOf(simboloTipoVariable));
                    simboloParametros.getListaTipoDescripcion().add(new DescripcionTipo(simboloTipoVariable,null, DescripcionValor.dvArgumento));
                    simboloParametros.getListaVariables().add(simboloIdVariable);
                    RESULT = new SimboloParametros(simboloParametros.getListaVariables(), simboloParametros.getListaTipoDescripcion());
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("MAS_PARAMETROS",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // MAS_PARAMETROS ::= identificador identificador 
            {
              SimboloParametros RESULT =null;
		int simboloTipoVariableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int simboloTipoVariableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String simboloTipoVariable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int simboloIdVariableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int simboloIdVariableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String simboloIdVariable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // Comprobamos el tipo
                    if (DescripcionValor.dvTipo != tablaSimbolos.consultar(String.valueOf(simboloTipoVariable)).getDescripcionValor()){
                        String mensajeError = "Excepción en la semántica del lenguaje. Tipo de los parámetros es incorrecto.";
                        gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                        throw new Exception(mensajeError);                
                    }
                    comprobarErrorTipoSubjacenteBasico(String.valueOf(simboloTipoVariable));
                    RESULT = new SimboloParametros(simboloIdVariable, simboloTipoVariable);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("MAS_PARAMETROS",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // RETURN ::= i_return VALORES fin_instruccion 
            {
              SimboloFuncion RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimboloValores val = (SimboloValores)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                if(DescripcionValor.dvNull != val.getDescripcionValor() && !esId(val)){
                    String mensajeError = "Excepción en la semántica del lenguaje. Descripción valor erroneo en el retorno: " + val.getDescripcionValor() + ".";
                    gf.escribirError("src/Salidas/Errores/ErroresSemanticos.txt", mensajeError);
                    throw new Exception(mensajeError);     
                } 
                if (DescripcionValor.dvNull == val.getDescripcionValor() ) {
                    RESULT = new SimboloFuncion(val.getTipoSubjacenteBasico(), val.getIdVariable());
                } 
                if (esId(val)) {
                    RESULT = new SimboloFuncion(tablaSimbolos.consultar(val.getNombreTipo()).getTipoSubjacenteBasico(), val.getIdVariable());
                }
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("RETURN",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // RETURN ::= 
            {
              SimboloFuncion RESULT =null;
		
                 RESULT = new SimboloFuncion();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("RETURN",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // ETIQUETA_PASAR ::= LAMBDA 
            {
              String RESULT =null;
		
                    // CÓDIGO INTERMEDIO GENERAMOS NUEVA ETIQUETA E INSTRUCCION PASAR
                    generadorCodigo3D.getTablaEtiquetas().add("ETIQUETA" + generadorCodigo3D.getNumeroEtiqueta());
                    generadorCodigo3D.sumarEtiqueta();
                    generadorCodigo3D.generarCodigo3Direcciones(Operacion3Direcciones.etiquetaPasar, null, null, new Operador(String.valueOf(generadorCodigo3D.getNumeroEtiqueta()), CategoriaOperador.etiqueta));
                    RESULT = String.valueOf(generadorCodigo3D.getNumeroEtiqueta());
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ETIQUETA_PASAR",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // SUMAR_AMBITO ::= 
            {
              Object RESULT =null;
		                        
                        tablaSimbolos.entrarBloque();
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SUMAR_AMBITO",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // RESTAR_AMBITO ::= 
            {
              Object RESULT =null;
		                     
                        tablaSimbolos.salirBloque();
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("RESTAR_AMBITO",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // M0 ::= 
            {
              Object RESULT =null;
		  
            tablaSimbolos.poner("bool", new DescripcionTipo(TipoSubjacenteBasico.tsBooleano, 2, 0, 1));
            tablaSimbolos.poner("str", new DescripcionTipo(TipoSubjacenteBasico.tsString, 0, 0, 1024));
            tablaSimbolos.poner("int", new DescripcionTipo(TipoSubjacenteBasico.tsEntero, 4, Integer.MIN_VALUE, Integer.MAX_VALUE));
            tablaSimbolos.poner("void", new DescripcionTipo(TipoSubjacenteBasico.tsVoid, 0, 0, 0));
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("M0",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // M1 ::= 
            {
              Object RESULT =null;
		                  
            // CÓDIGO INTERMEDIO-> INSTRUCCION ETIQUETA PASAR CUANDO LA CONDICIÓN ES VERDADERA
            generadorCodigo3D.generarCodigo3Direcciones(Operacion3Direcciones.etiquetaPasar, null, null, new Operador(generadorCodigo3D.getPilaTrue().pop(), CategoriaOperador.etiqueta));
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("M1",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // M2 ::= 
            {
              Object RESULT =null;
		
            // CÓDIGO INTERMEDIO-> INSTRUCCION ETIQUETA PASAR CUANDO LA CONDICIÓN ES FALSA
            generadorCodigo3D.generarCodigo3Direcciones(Operacion3Direcciones.etiquetaPasar, null, null, new Operador(generadorCodigo3D.getPilaFalse().pop(), CategoriaOperador.etiqueta));
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("M2",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // VALORES ::= INICIALIZAR_OPERADOR_ARITMETICO 
            {
              SimboloValores RESULT =null;
		int inicializar_operadorleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int inicializar_operadorright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimboloOperadores inicializar_operador = (SimboloOperadores)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                    SimboloValores valor = new SimboloValores(TipoSubjacenteBasico.tsEntero);                   
                    if (inicializar_operador.esConstante()) {                        
                        valor.setEsConstante(inicializar_operador.esConstante());
                        valor.setIdVariable(inicializar_operador.getIdVariable());
                        valor.setValorTipo(inicializar_operador.getValorTipo());
                        RESULT = valor;
                    }else{
                        valor.setEsConstante(false);
                        valor.setIdVariable(inicializar_operador.getIdVariable());
                        RESULT = valor;
                    }
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALORES",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // VALORES ::= booleano 
            {
              SimboloValores RESULT =null;
		int bool_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int bool_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String bool_value = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // CÓDIGO INTERMEDIO-> INSTRUCCION COPIA Y VARIABLE TEMPORAL
                    generadorCodigo3D.getTV().nuevaVariable("Variable temporal", generadorCodigo3D.getTP().subprogramaActual(), tablaSimbolos.consultar("bool").getOcupacion(), 0, tablaSimbolos.consultar("bool").getTipoSubjacenteBasico());
                    generadorCodigo3D.generarCodigo3Direcciones(Operacion3Direcciones.copia, new Operador(bool_value, CategoriaOperador.valorBooleano), null, new Operador(String.valueOf(generadorCodigo3D.getTV().getNv()), CategoriaOperador.variable));
                    RESULT = new SimboloValores(TipoSubjacenteBasico.tsBooleano, Boolean.parseBoolean(bool_value),String.valueOf(generadorCodigo3D.getTV().getNv()) ); 
                
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALORES",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // VALORES ::= INICIALIZAR_OPERADOR_BOOLEANO 
            {
              SimboloValores RESULT =null;
		int inicializar_operadorleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int inicializar_operadorright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimboloOperadores inicializar_operador = (SimboloOperadores)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
				
                    if (inicializar_operador.esConstante()) { 
                        RESULT = new SimboloValores(TipoSubjacenteBasico.tsBooleano,inicializar_operador.esConstante(),inicializar_operador.getIdVariable(), inicializar_operador.getValorTipo());
                    }else{
                        RESULT = new SimboloValores(TipoSubjacenteBasico.tsBooleano,inicializar_operador.esConstante() ,inicializar_operador.getIdVariable());
                    }
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALORES",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // VALORES ::= SIGNO entero 
            {
              SimboloValores RESULT =null;
		int simbolo_signoleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int simbolo_signoright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimboloValores simbolo_signo = (SimboloValores)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int entero_valorleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int entero_valorright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String entero_valor = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // CÓDIGO INTERMEDIO-> INSTRUCCION COPIA Y VARIABLE TEMPORAL
                    generadorCodigo3D.getTV().nuevaVariable("Variable temporal", generadorCodigo3D.getTP().subprogramaActual(), tablaSimbolos.consultar("int").getOcupacion(), 0, tablaSimbolos.consultar("int").getTipoSubjacenteBasico());
                    if (simbolo_signo != null && simbolo_signo.tieneSigno() && simbolo_signo.esNegativo()) {
                        Operador opValorAritmetico = new Operador(String.valueOf(-Integer.parseInt(entero_valor)), CategoriaOperador.valorAritmetico);
                        Operador opVariable = new Operador(String.valueOf(generadorCodigo3D.getTV().getNv()), CategoriaOperador.variable);
                        generadorCodigo3D.generarCodigo3Direcciones(Operacion3Direcciones.copia,opValorAritmetico,null,opVariable);
                        RESULT = new SimboloValores(TipoSubjacenteBasico.tsEntero, -Integer.parseInt(entero_valor), String.valueOf(generadorCodigo3D.getTV().getNv()));
                    }else{
                        Operador opValorAritmetico = new Operador(String.valueOf(Integer.parseInt(entero_valor)), CategoriaOperador.valorAritmetico);
                        Operador opVariable = new Operador(String.valueOf(generadorCodigo3D.getTV().getNv()), CategoriaOperador.variable);
                        generadorCodigo3D.generarCodigo3Direcciones(Operacion3Direcciones.copia,opValorAritmetico,null,opVariable);
                        RESULT = new SimboloValores(TipoSubjacenteBasico.tsEntero, Integer.parseInt(entero_valor), String.valueOf(generadorCodigo3D.getTV().getNv()));
                    }
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALORES",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // VALORES ::= cadena 
            {
              SimboloValores RESULT =null;
		int text_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int text_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String text_value = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                    if (text_value.replace("\"", "").length() > 255){
                        String mensajeError = "Excepción en la sintaxis del programa, error al sobrepasar límites del String. Tiene " + text_value.replace("\"", "").length() + " carácteres y debería tener menor o igual a  255";
                        gf.escribirError("src/Salidas/Errores/ErroresSintacticos.txt", mensajeError);
                        throw new Exception(mensajeError);
                    }
                    // CÓDIGO INTERMEDIO-> INSTRUCCION COPIA Y VARIABLE TEMPORAL
                    SimboloValores valor = new SimboloValores(TipoSubjacenteBasico.tsString, text_value.replace("\"", ""));
                    valor.setEsString(true);
                    generadorCodigo3D.getTV().nuevaVariable("Variable temporal", generadorCodigo3D.getTP().subprogramaActual(), text_value.replace("\"", "").length() * 2, 0, tablaSimbolos.consultar("str").getTipoSubjacenteBasico());
                    valor.setIdVariable(String.valueOf(generadorCodigo3D.getTV().getNv()));
                    valor.setOcupacionString(text_value.replace("\"", "").length() * 2);
                    Operacion3Direcciones opCopia = Operacion3Direcciones.copia;
                    Operador opString = new Operador(text_value, CategoriaOperador.valorString);
                    Operador opString2 = new Operador(String.valueOf(generadorCodigo3D.getTV().getNv()), CategoriaOperador.variable);
                    generadorCodigo3D.generarCodigo3Direcciones(opCopia, opString, null, opString2 );
                    RESULT = valor;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALORES",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // VALORES ::= LLAMAR_FUNCION 
            {
              SimboloValores RESULT =null;
		int simboloLlamarleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int simboloLlamarright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimboloFuncion simboloLlamar = (SimboloFuncion)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    SimboloValores valor = new SimboloValores(DescripcionValor.dvSubprograma, tablaSimbolos.consultar(simboloLlamar.getSubprograma()).getNombreId());
                    // CÓDIGO INTERMEDIO INSTRUCCION COPIA Y VARIABLE TEMPORAL
                    generadorCodigo3D.getTV().nuevaVariable("Variable temporal", generadorCodigo3D.getTP().subprogramaActual(), tablaSimbolos.consultar(tablaSimbolos.consultar(simboloLlamar.getSubprograma()).getNombreId()).getOcupacion(), 0, tablaSimbolos.consultar(tablaSimbolos.consultar(simboloLlamar.getSubprograma()).getNombreId()).getTipoSubjacenteBasico());
                    valor.setIdVariable(String.valueOf(generadorCodigo3D.getTV().getNv()));
                    Operacion3Direcciones opCopia = Operacion3Direcciones.copia;
                    Operador opLlamar = new Operador(String.valueOf(simboloLlamar.getnSubprograma()), CategoriaOperador.subprograma);
                    Operador opVarTemp = new Operador(String.valueOf(generadorCodigo3D.getTV().getNv()), CategoriaOperador.variable);
                    generadorCodigo3D.generarCodigo3Direcciones(opCopia, opLlamar, null, opVarTemp);
                    RESULT = valor;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALORES",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // VALORES ::= identificador 
            {
              SimboloValores RESULT =null;
		int id_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int id_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id_value = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    if (DescripcionValor.dvConstante == tablaSimbolos.consultar(id_value).getDescripcionValor() ) {                       
                        RESULT = new SimboloValores(tablaSimbolos.consultar(id_value).getDescripcionValor(),tablaSimbolos.consultar(id_value).getNombreId(), tablaSimbolos.consultar(id_value).getValorConstante(), true, String.valueOf(tablaSimbolos.consultar(id_value).getIdCodigoIntermedio()));
                    }else{
                        RESULT = new SimboloValores(tablaSimbolos.consultar(id_value).getDescripcionValor(),tablaSimbolos.consultar(id_value).getNombreId(), String.valueOf(tablaSimbolos.consultar(id_value).getIdCodigoIntermedio()));
                    }     
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALORES",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // LAMBDA ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LAMBDA",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$Parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
              return CUP$Parser$do_action_part00000000(
                               CUP$Parser$act_num,
                               CUP$Parser$parser,
                               CUP$Parser$stack,
                               CUP$Parser$top);
    }
}

}
